// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/KasperSaaby/calculatron-service/internal/domain/values"
	"github.com/KasperSaaby/calculatron-service/internal/store"
	"sync"
)

// Ensure, that HistoryStoreMock does implement store.HistoryStore.
// If this is not the case, regenerate this file with moq.
var _ store.HistoryStore = &HistoryStoreMock{}

// HistoryStoreMock is a mock implementation of store.HistoryStore.
//
//	func TestSomethingThatUsesHistoryStore(t *testing.T) {
//
//		// make and configure a mocked store.HistoryStore
//		mockedHistoryStore := &HistoryStoreMock{
//			GetAllCalculationsFunc: func(ctx context.Context, offset int, limit int) ([]values.HistoryEntry, error) {
//				panic("mock out the GetAllCalculations method")
//			},
//			GetCalculationByIDFunc: func(ctx context.Context, operationID values.OperationID) (values.HistoryEntry, error) {
//				panic("mock out the GetCalculationByID method")
//			},
//			SaveCalculationFunc: func(ctx context.Context, entry values.HistoryEntry) error {
//				panic("mock out the SaveCalculation method")
//			},
//		}
//
//		// use mockedHistoryStore in code that requires store.HistoryStore
//		// and then make assertions.
//
//	}
type HistoryStoreMock struct {
	// GetAllCalculationsFunc mocks the GetAllCalculations method.
	GetAllCalculationsFunc func(ctx context.Context, offset int, limit int) ([]values.HistoryEntry, error)

	// GetCalculationByIDFunc mocks the GetCalculationByID method.
	GetCalculationByIDFunc func(ctx context.Context, operationID values.OperationID) (values.HistoryEntry, error)

	// SaveCalculationFunc mocks the SaveCalculation method.
	SaveCalculationFunc func(ctx context.Context, entry values.HistoryEntry) error

	// calls tracks calls to the methods.
	calls struct {
		// GetAllCalculations holds details about calls to the GetAllCalculations method.
		GetAllCalculations []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetCalculationByID holds details about calls to the GetCalculationByID method.
		GetCalculationByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OperationID is the operationID argument value.
			OperationID values.OperationID
		}
		// SaveCalculation holds details about calls to the SaveCalculation method.
		SaveCalculation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Entry is the entry argument value.
			Entry values.HistoryEntry
		}
	}
	lockGetAllCalculations sync.RWMutex
	lockGetCalculationByID sync.RWMutex
	lockSaveCalculation    sync.RWMutex
}

// GetAllCalculations calls GetAllCalculationsFunc.
func (mock *HistoryStoreMock) GetAllCalculations(ctx context.Context, offset int, limit int) ([]values.HistoryEntry, error) {
	if mock.GetAllCalculationsFunc == nil {
		panic("HistoryStoreMock.GetAllCalculationsFunc: method is nil but HistoryStore.GetAllCalculations was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}{
		Ctx:    ctx,
		Offset: offset,
		Limit:  limit,
	}
	mock.lockGetAllCalculations.Lock()
	mock.calls.GetAllCalculations = append(mock.calls.GetAllCalculations, callInfo)
	mock.lockGetAllCalculations.Unlock()
	return mock.GetAllCalculationsFunc(ctx, offset, limit)
}

// GetAllCalculationsCalls gets all the calls that were made to GetAllCalculations.
// Check the length with:
//
//	len(mockedHistoryStore.GetAllCalculationsCalls())
func (mock *HistoryStoreMock) GetAllCalculationsCalls() []struct {
	Ctx    context.Context
	Offset int
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}
	mock.lockGetAllCalculations.RLock()
	calls = mock.calls.GetAllCalculations
	mock.lockGetAllCalculations.RUnlock()
	return calls
}

// GetCalculationByID calls GetCalculationByIDFunc.
func (mock *HistoryStoreMock) GetCalculationByID(ctx context.Context, operationID values.OperationID) (values.HistoryEntry, error) {
	if mock.GetCalculationByIDFunc == nil {
		panic("HistoryStoreMock.GetCalculationByIDFunc: method is nil but HistoryStore.GetCalculationByID was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		OperationID values.OperationID
	}{
		Ctx:         ctx,
		OperationID: operationID,
	}
	mock.lockGetCalculationByID.Lock()
	mock.calls.GetCalculationByID = append(mock.calls.GetCalculationByID, callInfo)
	mock.lockGetCalculationByID.Unlock()
	return mock.GetCalculationByIDFunc(ctx, operationID)
}

// GetCalculationByIDCalls gets all the calls that were made to GetCalculationByID.
// Check the length with:
//
//	len(mockedHistoryStore.GetCalculationByIDCalls())
func (mock *HistoryStoreMock) GetCalculationByIDCalls() []struct {
	Ctx         context.Context
	OperationID values.OperationID
} {
	var calls []struct {
		Ctx         context.Context
		OperationID values.OperationID
	}
	mock.lockGetCalculationByID.RLock()
	calls = mock.calls.GetCalculationByID
	mock.lockGetCalculationByID.RUnlock()
	return calls
}

// SaveCalculation calls SaveCalculationFunc.
func (mock *HistoryStoreMock) SaveCalculation(ctx context.Context, entry values.HistoryEntry) error {
	if mock.SaveCalculationFunc == nil {
		panic("HistoryStoreMock.SaveCalculationFunc: method is nil but HistoryStore.SaveCalculation was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Entry values.HistoryEntry
	}{
		Ctx:   ctx,
		Entry: entry,
	}
	mock.lockSaveCalculation.Lock()
	mock.calls.SaveCalculation = append(mock.calls.SaveCalculation, callInfo)
	mock.lockSaveCalculation.Unlock()
	return mock.SaveCalculationFunc(ctx, entry)
}

// SaveCalculationCalls gets all the calls that were made to SaveCalculation.
// Check the length with:
//
//	len(mockedHistoryStore.SaveCalculationCalls())
func (mock *HistoryStoreMock) SaveCalculationCalls() []struct {
	Ctx   context.Context
	Entry values.HistoryEntry
} {
	var calls []struct {
		Ctx   context.Context
		Entry values.HistoryEntry
	}
	mock.lockSaveCalculation.RLock()
	calls = mock.calls.SaveCalculation
	mock.lockSaveCalculation.RUnlock()
	return calls
}
